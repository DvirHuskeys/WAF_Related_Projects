<story-context id="{bmad_folder}/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>2</epicId>
    <storyId>2</storyId>
    <title>Fingerprinting & Scoring Pipeline</title>
    <status>ready-for-dev</status>
    <generatedAt>2025-11-30</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/2-2-fingerprinting-scores.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>As the enrichment job</asA>
    <iWant>I want to detect WAF/CDN stacks and generate drift/downtime/attack scores</iWant>
    <soThat>so that persona and reporting modules have consistent telemetry to work with.</soThat>
    <tasks>      <![CDATA[
      - [ ] Implement fingerprinting helper (AC: 1–2)  
  - [ ] Update `backend/services/fingerprint.py` to wrap wafw00f with timeout + fallback.  
  - [ ] Add deterministic seed when fallback is used.  
- [ ] Scoring logic (AC: 1 & 4)  
  - [ ] Create `backend/services/scoring.py` with configurable thresholds.  
  - [ ] Document how to adjust heuristics in README.  
- [ ] Integrate into CLI (AC: 1,3,5)  
  - [ ] Enrichment CLI (Story 2.1) calls fingerprint/scoring and writes values.  
  - [ ] Log per-domain summary + warnings; continue on errors.  
- [ ] Tests / smoke (AC: 2,4)  
  - [ ] Add quick unit tests or notebook verifying outputs between 0–1.  
  - [ ] Verify fallback path returns consistent values across runs.
      ]]></tasks>
  </story>

  <acceptanceCriteria>      <![CDATA[
      1. Given a domain row processed by Story 2.1, when fingerprinting runs then `detected_waf`, `detected_cdn`, `config_drift_score`, `downtime_risk_score`, `attack_surface_score`, `last_observed`, and raw JSON are persisted in DuckDB.
2. The pipeline honors env toggle `USE_WAFW00F=1` to use real wafw00f detection; when disabled, a deterministic fallback (seeded random) is used so offline runs are predictable.
3. Errors from wafw00f or network failures are caught and logged; processing continues for remaining domains.
4. Scoring heuristic ensures values are normalized between 0.0–1.0 and can be tuned centrally (e.g., `scoring.py`).
5. CLI output shows per-domain summary (e.g., “example.com → cloudflare/cloudflare drift 0.74”) and references the job ID from Story 2.4.
      ]]></acceptanceCriteria>

  <artifacts>
    <docs>      <doc path="docs/sprint-artifacts/2-2-fingerprinting-scores.md" title="Fingerprinting &amp; Scoring Pipeline" section="Story Draft" snippet="As the enrichment job, I want to detect WAF/CDN stacks and generate drift/downtime/attack scores, so that persona and reporting modules have consistent telemetry to work with." />
      <doc path="docs/epics.md" title="WAF Security - Epic Breakdown" section="Story 2.2" snippet="As an enrichment job, I want to detect WAF/CDN providers and heuristic scores so persona service has consistent inputs. **Acceptance Criteria** • **Given** a domain fetched from the CLI • **When** fingerprinting runs • **Then** `detected_waf`, `detected_cdn`, drift/downtime/attack scores, `last_observed`, and raw JSON are stored • **And** `USE_WAFW00F` env…" />
      <doc path="docs/prd.md" title="Product Requirements Document" section="Executive Summary" snippet="WAF Security establishes a local-first “insight spine” that combines WAFtotal (vendor-agnostic managed-rule transparency) with GTM Radar (domain fingerprinting + storytelling) so every security, architecture, and GTM conversation starts with evidence instead of guesswork. By harvesting domain signals, normalizing Cloudflare/AWS/Akamai rule packs, and…" />
      <doc path="docs/architecture.md" title="Architecture Specification" section="Project Context &amp; Goals" snippet="- **Deployment Reality:** Local-first sandbox meant to run entirely on a lone laptop (Streamlit UI, FastAPI services, DuckDB file storage). No cloud infra, no Postgres/React rewrite—lightweight scripts + HTML artifacts are sufficient so iteration stays fast. - **Primary Outcomes:** 1. Fingerprint domains (CLI + FastAPI) and persist results in DuckDB. 2.…" />
      <doc path="docs/product-brief-WAF Security-2025-11-30.md" title="Product Brief" section="Executive Summary" snippet="WAF Security is building an internal “insight spine” that fuses two sibling ideas—**WAFtotal**, a vendor-agnostic managed-rule transparency experience, and **GTM Radar**, a domain fingerprinting + storytelling engine for sales and marketing teams. Together they deliver three promises: (1) decode any prospect’s WAF/CDN posture in minutes, (2) expose…" />
      <doc path="docs/research-market-2025-11-30.md" title="Market/Domain Research" section="Executive Summary" snippet="- The global web application firewall (WAF) market is scaling aggressively: SNS Insider pegs it at **USD 6.35 B in 2023 with a path to USD 28.6 B by 2032 (18.2% CAGR)**, while ResearchAndMarkets estimates **USD 6.22 B in 2024 growing to USD 19.2 B by 2033 (13.3% CAGR)**, giving us a triangulated TAM envelope of USD 19–29 B within a decade. - [Source: SNS…" /></docs>
    <code>      <code path="scripts/domain_enrich.py" kind="cli" symbol="main" lines="20-87" reason="Implements CSV ingestion pipeline for enrichment CLIs." />
      <code path="backend/services/fingerprint.py" kind="service" symbol="detect_stack" lines="21-51" reason="Detects WAF/CDN stacks and scoring heuristics reused across Epic 2." />
      <code path="backend/services/storage.py" kind="service" symbol="get_connection" lines="11-68" reason="Persists enrichment + rule sync results mentioned in pipeline stories." /></code>
    <dependencies>      <dependency name="duckdb" version="1.1.3" scope="storage" />
      <dependency name="typer" version="0.12.5" scope="cli" />
      <dependency name="wafw00f" version="2.2.0" scope="security" />
      <dependency name="rich" version="13.9.2" scope="cli" /></dependencies>
  </artifacts>

  <constraints>      <![CDATA[
      - Aligns with PRD FR2 + FR4 and architecture Section 2 (duckdb data flow).  
- Consider hooking into job logging table once Story 2.4 is complete.  
- Keep heuristics accessible for future tuning (maybe YAML config).

### Project Structure Notes

- Functions belong under `backend/services/`; CLI should import them rather than duplicating logic.  
- No new directories needed.

### References

- [Source: docs/epics.md#story-22-fingerprinting--scoring-pipeline]  
- [Source: docs/prd.md#functional-requirements FR2–FR4]  
- [Source: docs/architecture.md#2-architecture-overview]
      ]]></constraints>
  <interfaces>      <interface name="domain_enrich CLI" kind="CLI command" signature="python scripts/domain_enrich.py data/samples/domains.csv [--limit]" path="scripts/domain_enrich.py" /></interfaces>
  <tests>
    <standards>      <![CDATA[
      - [x] domain_enrich.py run Command: `python scripts/domain_enrich.py data/samples/domains.csv` Result: Generated four enriched records in DuckDB, offline heuristics used. - [x] rule_sync/run.py Command: `python scripts/rule_sync/run.py cloudflare --source data/rules/cloudflare_sample.json` Result: Loaded two sample managed rules. - [x] API schema test…
      ]]></standards>
    <locations>      <![CDATA[
      tests/, scripts/, ui/
      ]]></locations>
    <ideas>      <![CDATA[
      AC1: Verify Given a domain row processed by Story 2.1, when fingerprinting runs then `detected_waf`, `detected_cdn`, `config_drift_score`, `downtime_risk_score`, `attack_surface_score`, `last_observed`, and raw JSON are persisted in DuckDB.; AC2: Verify The pipeline honors env toggle `USE_WAFW00F=1` to use real wafw00f detection; when disabled, a deterministic fallback (seeded random) is used so offline runs are predictable.; AC3: Verify Errors from wafw00f or network failures are caught and logged; processing continues for remaining domains.; AC4: Verify Scoring heuristic ensures values are normalized between 0.0–1.0 and can be tuned centrally (e.g., `scoring.py`).; AC5: Verify CLI output shows per-domain summary (e.g., “example.com → cloudflare/cloudflare drift 0.74”) and references the job ID from Story 2.4.
      ]]></ideas>
  </tests>
</story-context>
